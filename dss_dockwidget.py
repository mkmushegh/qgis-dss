# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DSSDockWidget
                                 A QGIS plugin
 Decision Support System
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-07-27
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Mushegh Mkrtchyan
        email                : mkrtchyan.mushegh@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
import traceback
from qgis.PyQt import QtWidgets, uic, QtGui
from qgis.PyQt.QtCore import pyqtSignal, QVariant, Qt
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.core import (
    QgsPointXY,
    QgsSpatialIndex,
    QgsFeatureRequest,
    QgsCoordinateTransform,
    QgsProject,
    QgsGeometry,
    QgsFeature,
    QgsVectorLayer,
    QgsWkbTypes,
    Qgis,
    QgsMessageLog,
    QgsField,
    QgsGraduatedSymbolRenderer, 
    QgsRendererRange, 
    QgsSymbol,
    QgsFillSymbol,
    QgsLinePatternFillSymbolLayer,
    QgsLineSymbol,
    QgsSimpleLineSymbolLayer,
    QgsUnitTypes
)
from qgis.gui import QgsMapToolEmitPoint
from PyQt5.QtGui import QColor

FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'dss_dockwidget_base.ui'))

MESSAGE_CATEGORY = 'Messages'

def enable_remote_debugging():
    try:
        import ptvsd
        QgsMessageLog.logMessage("ptvsd imported successfully!", MESSAGE_CATEGORY, Qgis.Info)
        if ptvsd.is_attached():
            QgsMessageLog.logMessage("Remote Debug for Visual Studio is already active", MESSAGE_CATEGORY, Qgis.Info)
            return
        ptvsd.enable_attach(address=('localhost', 5678))
        QgsMessageLog.logMessage("Attached remote Debug for Visual Studio", MESSAGE_CATEGORY, Qgis.Info)
    except Exception as e:
        exc_type, exc_value, exc_traceback = sys.exc_info()
        format_exception = traceback.format_exception(exc_type, exc_value, exc_traceback)
        QgsMessageLog.logMessage(str(e), MESSAGE_CATEGORY, Qgis.Critical)        
        QgsMessageLog.logMessage(repr(format_exception[0]), MESSAGE_CATEGORY, Qgis.Critical)
        QgsMessageLog.logMessage(repr(format_exception[1]), MESSAGE_CATEGORY, Qgis.Critical)
        QgsMessageLog.logMessage(repr(format_exception[2]), MESSAGE_CATEGORY, Qgis.Critical)


class DSSDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, iface, parent=None):
        """Constructor."""
        enable_remote_debugging()
        super().__init__(parent)
        self.setupUi(self)
        self.iface = iface
        self.btnCalculate.clicked.connect(self.calculate_closest_waterbody)
        self.nearest_water_body_feature = None  # Initialize the variable
        self.btnPickPoint.clicked.connect(self.pick_point_from_canvas)
        
    def pick_point_from_canvas(self):
        """Activates the map tool to pick a point from the canvas."""
        self.canvas = self.iface.mapCanvas()
        self.tool = QgsMapToolEmitPoint(self.canvas)
        self.tool.canvasClicked.connect(self.handle_canvas_click)
        self.canvas.setMapTool(self.tool)

    def handle_canvas_click(self, point, button):
        """Handles the point picked from the canvas."""
        self.spinBoxLat.setValue(point.x())
        self.spinBoxLon.setValue(point.y())
        self.canvas.unsetMapTool(self.tool)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def calculate_closest_waterbody(self):
        """Calculates the closest water body and processes intersecting features."""
        lat = self.spinBoxLat.value()
        lon = self.spinBoxLon.value()
        point = QgsPointXY(lat, lon)

        water_bodies_layer = self.cmbWaterBodies.currentLayer()
        if not self._validate_layer(water_bodies_layer, "water bodies"):
            return

        nearest_water_body_feature = self._get_nearest_feature(water_bodies_layer, point)
        if not nearest_water_body_feature:
            QMessageBox.warning(self, "Error", "No water bodies found near the point.")
            return

        self.nearest_water_body_feature = nearest_water_body_feature  # Store for later use

        water_body_geom = nearest_water_body_feature.geometry()
        catchments_layer = self.cmbCatchments.currentLayer()
        if not self._validate_layer(catchments_layer, "catchments"):
            return

        # Ensure geometries are in the same CRS
        if catchments_layer.crs() != water_bodies_layer.crs():
            transformer = QgsCoordinateTransform(water_bodies_layer.crs(), catchments_layer.crs(), QgsProject.instance())
            water_body_geom.transform(transformer)

        # intersecting_catchment = self._find_intersecting_feature(catchments_layer, water_body_geom)
        intersecting_catchment = self._find_intersecting_feature(catchments_layer, water_body_geom, point)
        if not intersecting_catchment:
            QMessageBox.warning(self, "Error", "No catchments intersect with the water body.")
            return

        catchment_id_field = 'RCode'  # Replace with your actual field name
        catchment_id_value = intersecting_catchment[catchment_id_field]
        if not catchment_id_value:
            QMessageBox.warning(self, "Error", "Catchment feature has no RCode value.")
            return

        selected_catchments = self.select_catchment_features_by_id(catchments_layer, catchment_id_field, catchment_id_value)
        if not selected_catchments:
            QMessageBox.warning(self, "Error", "No matching catchment features found.")
            return
        selected_catchments.append(intersecting_catchment)

        union_geometry = self._unify_geometries(selected_catchments)
        if not union_geometry:
            QMessageBox.warning(self, "Error", "Union of geometries failed.")
            return

        # Add the union geometry as a new layer
        # self.add_geometry_as_layer(union_geometry, catchments_layer.crs())

        # Process intersecting features, including water bodies
        results = self.process_intersecting_features(union_geometry, catchments_layer.crs())
        
        # Add the union geometry as a new layer with WS attributes
        self.add_geometry_as_layer_with_attributes(union_geometry, catchments_layer.crs(), results['ws_surface'], results['ws_groundwater'], results['ws_total'])

        self.display_results(results)


    def display_results(self, results):
        # Append Water Stress metrics to the message
        message = "Water Stress (WS) Metrics:\n"
        message += f"  - WS Surface: ({results['surface_water_abstraction']:.2f} / ({results['natural_flow']:.2f} - {results['ecological_flow']:.2f})) * 100 = {results['ws_surface']:.2f} %\n"
        message += f"  - WS Groundwater: ({results['groundwater_abstraction']:.2f} / {results['groundwater_usable']:.2f}) * 100 = {results['ws_groundwater']:.2f} %\n"
        message += f"  - WS Total: (({results['surface_water_abstraction']:.2f} + {results['groundwater_abstraction']:.2f}) / "
        message += f"({results['natural_flow']:.2f} - {results['ecological_flow']:.2f} + {results['groundwater_usable']:.2f})) * 100 = {results['ws_total']:.2f} %\n\n"

        # Set a fixed width for the message box
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Calculation Results")
        msg_box.setText(message)
        msg_box.setTextInteractionFlags(Qt.TextSelectableByMouse)
        msg_box.setStyleSheet("QLabel{min-width: 600px;}")
        msg_box.exec_()

    def create_custom_symbol(self, color):
        # Create the main fill symbol
        symbol = QgsFillSymbol()

        # 1. Line Pattern Fill Layer
        line_pattern_layer = QgsLinePatternFillSymbolLayer()
        line_pattern_layer.setAngle(45)
        line_pattern_layer.setDistance(1)  # Distance between lines in mm
        line_pattern_layer.setDistanceUnit(QgsUnitTypes.RenderMillimeters)
        line_pattern_layer.setLineWidth(0.26)  # Line width in mm
        line_pattern_layer.setLineWidthUnit(QgsUnitTypes.RenderMillimeters)

        # Create a line symbol for the pattern
        line_symbol = QgsLineSymbol()
        line_symbol.setColor(QColor(color))
        line_symbol.setWidth(0.3)  # Line width in mm
        line_symbol.setWidthUnit(QgsUnitTypes.RenderMillimeters)

        # Set the sub-symbol for the line pattern
        line_pattern_layer.setSubSymbol(line_symbol)

        # 2. Simple Line Layer (Outline)
        outline_layer = QgsSimpleLineSymbolLayer()
        outline_layer.setColor(QColor(color))
        outline_layer.setWidth(0.66)  # Line width in mm
        outline_layer.setWidthUnit(QgsUnitTypes.RenderMillimeters)

        # Clear existing layers and add our custom layers
        symbol.deleteSymbolLayer(0)  # Remove default layer
        symbol.appendSymbolLayer(line_pattern_layer)
        symbol.appendSymbolLayer(outline_layer)

        return symbol

    def add_geometry_as_layer_with_attributes(self, geometry, crs, ws_surface, ws_groundwater, ws_total):
        """Adds the given geometry as a new layer to the map with WS attributes."""
        layer = QgsVectorLayer("Polygon?crs={}".format(crs.authid()), "WS for the selected point", "memory")
        pr = layer.dataProvider()
        
        # Add fields for WS attributes
        pr.addAttributes([
            QgsField("WS_Surface", QVariant.Double),
            QgsField("WS_Groundwater", QVariant.Double),
            QgsField("WS_Total", QVariant.Double)
        ])
        layer.updateFields()
        
        # Create a feature with the geometry and WS attributes
        feature = QgsFeature()
        feature.setGeometry(geometry)
        feature.setAttributes([ws_surface, ws_groundwater, ws_total])
        pr.addFeatures([feature])
        layer.updateExtents()
        
        # Add the layer to the project
        QgsProject.instance().addMapLayer(layer)
        
        # Apply a graduated renderer to color the layer based on WS_Total

        # Define color ranges
        ranges = [
            (0, 25, 'green', 'Not Stressed'),
            (25, 50, 'yellow', 'Low Stress'),
            (50, 75, 'orange', 'Moderate Stress'),
            (75, 100, 'red', 'Stressed'),
            (100, float('inf'), 'darkred', 'Overstressed')
        ]

        # Create ranges for the renderer
        renderer_ranges = []
        for min_val, max_val, color_name, label in ranges:
            # Create the custom symbol with the specified color
            symbol = self.create_custom_symbol(color_name)
            # Create the renderer range
            range = QgsRendererRange(min_val, max_val, symbol, label)
            renderer_ranges.append(range)

        # Create and apply the renderer
        renderer = QgsGraduatedSymbolRenderer('WS_Total', renderer_ranges)
        renderer.setMode(QgsGraduatedSymbolRenderer.Custom)
        layer.setRenderer(renderer)
        layer.triggerRepaint()

    

    def _validate_layer(self, layer, layer_name):
        if not layer:
            QMessageBox.warning(self, "Error", f"Please select a {layer_name} layer.")
            return False
        if not layer.isSpatial():
            QMessageBox.warning(self, "Error", f"Selected {layer_name} layer is not spatial.")
            return False
        return True

    def _get_nearest_feature(self, layer, point):
        index = QgsSpatialIndex(layer.getFeatures())
        nearest_ids = index.nearestNeighbor(point, 1)
        if nearest_ids:
            request = QgsFeatureRequest(nearest_ids[0])
            return next(layer.getFeatures(request), None)
        return None

    def _find_intersecting_feature(self, layer, geometry, point):
        index = QgsSpatialIndex(layer.getFeatures())
        candidate_ids = index.intersects(geometry.boundingBox())
        max_intersection_length = 0
        best_feature = None
        min_distance = float('inf')

        for feature_id in candidate_ids:
            request = QgsFeatureRequest(feature_id)
            feature = next(layer.getFeatures(request))
            
            if feature.geometry().contains(QgsGeometry.fromPointXY(point)):
                return feature
            
            intersection = feature.geometry().intersection(geometry)
            distance = feature.geometry().distance(QgsGeometry.fromPointXY(point))
            if intersection.length() > max_intersection_length or (intersection.length() == max_intersection_length and distance < min_distance):
                max_intersection_length = intersection.length()
                min_distance = distance
                best_feature = feature

        return best_feature

    def _unify_geometries(self, features):
        geometries = [feature.geometry() for feature in features]
        union_geom = QgsGeometry.unaryUnion(geometries)
        return union_geom if not union_geom.isEmpty() else None

    def select_catchment_features_by_id(self, layer, id_field, value_given):
        selected_features = []
        value_given_str = str(value_given)
        try:
            value_given_num = int(value_given_str)
        except ValueError:
            return selected_features

        for feature in layer.getFeatures():
            id_value = feature[id_field]
            if id_value is None:
                continue
            id_value_str = str(id_value)
            try:
                id_value_num = int(id_value_str)
            except ValueError:
                continue

            if len(id_value_str) == len(value_given_str):
                if id_value_str[:-2] == value_given_str[:-2] and id_value_num >= value_given_num:
                    selected_features.append(feature)
            else:
                id_value_subset = id_value_str[:len(value_given_str)]
                if id_value_subset[:-2] == value_given_str[:-2] and int(id_value_subset) >= value_given_num:
                    selected_features.append(feature)
        return selected_features
      
    def process_intersecting_features(self, union_geometry, union_crs):       
        # ========================== process water abstraction
        layer = self.cmbWaterAbstraction.currentLayer()
        if not self._validate_layer(layer, 'Water Abstraction'):
            return
        transformed_geom = self._transform_geometry(union_geometry, union_crs, layer.crs())
        features = self._get_intersecting_features(layer, transformed_geom)
        
        surface_water_abstraction = 0
        groundwater_abstraction = 0
        total_water_abstraction = 0
        for feature in features:
            value = feature['abs_m3_yr']
            if value is None:
                continue
            try:
                value = float(value)
            except ValueError:
                continue
            
            if not isinstance(feature['Groundwate'],str):
                if feature['Groundwate'].isNull():
                    # then it is surface water abstraction
                    surface_water_abstraction += value
                else:
                    groundwater_abstraction += value
            else:
                groundwater_abstraction += value

        total_water_abstraction = surface_water_abstraction + groundwater_abstraction
        
        # ========================== process water discharge
        layer = self.cmbWaterDischarge.currentLayer()
        if not self._validate_layer(layer, 'Water Discharge'):
            return
        transformed_geom = self._transform_geometry(union_geometry, union_crs, layer.crs())
        features = self._get_intersecting_features(layer, transformed_geom)
        
        surface_water_discharge = 0
        groundwater_discharge = 0
        total_water_discharge = 0
        for feature in features:
            surface_value = feature['Tm3_y']
            groundwater_value = feature['Swg_m3_y']
            
            if surface_value is None:
                continue
            try:
                surface_value = float(surface_value)
            except ValueError:
                continue
            
            surface_water_discharge += surface_value
            
            if groundwater_value is None:
                continue
            try:
                groundwater_value = float(groundwater_value)
            except ValueError:
                continue
            
            groundwater_discharge += groundwater_value
            
        total_water_discharge = surface_water_discharge + groundwater_discharge
        
        # ========================== process groundwater
        layer = self.cmbGroundwater.currentLayer()
        if not self._validate_layer(layer, 'Groundwater Bodies'):
            return
        transformed_geom = self._transform_geometry(union_geometry, union_crs, layer.crs())
        features = self._get_intersecting_features(layer, transformed_geom)
        
        groundwater_usable = 0
        for feature in features:
            value = feature['GW_Usable']
            if value is None:
                continue
            try:
                value = float(value)
            except ValueError:
                continue
            
            groundwater_usable += value
            
        # ========================== process water bodies
        layer = self.cmbWaterBodies.currentLayer()
        if not self._validate_layer(layer, 'Water Bodies'):
            return
        # Use the nearest water body feature
        features = [self.nearest_water_body_feature]
        # Transform the feature's geometry to match the union CRS
        source_crs = layer.crs()
        target_crs = union_crs
        features = self._transform_features(features, source_crs, target_crs)
        
        """Processes only the nearest water body feature."""
        natural_flow = 0.0
        ecological_flow = 0.0
        if not features:
            return 
        
        feature = features[0]  # We only consider the nearest feature
        try:
            natural_flow = float(feature['W_av'])
        except (ValueError, TypeError, KeyError):
            natural_flow = 0.0

        try:
            ecological_flow = float(feature['W_ef'])
        except (ValueError, TypeError, KeyError):
            ecological_flow = 0.0

        # ========================== Calculate Water Stress (WS) metrics
        # Calculate Water Stress (WS) metrics
        try:
            ws_surface = ((surface_water_abstraction - surface_water_discharge) / (natural_flow - ecological_flow)) * 100
        except ZeroDivisionError:
            ws_surface = 0

        try:
            ws_groundwater = ((groundwater_abstraction - groundwater_discharge) / groundwater_usable) * 100
        except ZeroDivisionError:
            ws_groundwater = 0

        try:
            ws_total = ((total_water_abstraction - total_water_discharge) / (natural_flow - ecological_flow + groundwater_usable)) * 100
        except ZeroDivisionError:
            ws_total = 0

        return {
            'ws_surface': ws_surface,
            'ws_groundwater': ws_groundwater,
            'ws_total': ws_total,
            'surface_water_abstraction': surface_water_abstraction,
            'groundwater_abstraction': groundwater_abstraction,
            'natural_flow': natural_flow,
            'ecological_flow': ecological_flow,
            'groundwater_usable': groundwater_usable
        }

    def _transform_geometry(self, geometry, source_crs, target_crs):
        if source_crs != target_crs:
            transformer = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())
            transformed_geom = QgsGeometry(geometry)
            transformed_geom.transform(transformer)
            return transformed_geom
        return geometry

    def _transform_features(self, features, source_crs, target_crs):
        """Transforms the geometries of features from source CRS to target CRS."""
        transformed_features = []
        for feature in features:
            geom = QgsGeometry(feature.geometry())
            if source_crs != target_crs:
                transformer = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())
                geom.transform(transformer)
            feature_copy = QgsFeature(feature)
            feature_copy.setGeometry(geom)
            transformed_features.append(feature_copy)
        return transformed_features


    def _get_intersecting_features(self, layer, geometry):
        index = QgsSpatialIndex(layer.getFeatures())
        candidate_ids = index.intersects(geometry.boundingBox())
        intersecting_features = [
            feature for feature in layer.getFeatures(QgsFeatureRequest(candidate_ids))
            if feature.geometry().intersects(geometry)
        ]
        return intersecting_features